{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport { i as isFirestoreDataReference, a as isFirestoreQuery, b as isDatabaseReference, c as isStorageReference, n as noop, u as useFirebaseApp, d as isObject, e as checkWrittenTarget, f as isSSR, g as isPOJO, h as isDocumentRef, w as walkGet, j as callOnceWithArg, k as isCollectionRef, l as walkSet, m as getGlobalScope, o as authUserMap, s as setupOnAuthStateChanged, p as isClient, _ as _FirebaseAppInjectionKey } from './shared/vuefire.7f889637.mjs';\nexport { V as VueFireAppCheck, t as getCurrentUser, v as updateCurrentUserProfile, y as useAppCheck, x as useAppCheckToken, q as useCurrentUser, r as useIsCurrentUserLoaded } from './shared/vuefire.7f889637.mjs';\nimport { unref, ref, shallowRef, getCurrentScope, isRef, watch, onScopeDispose, getCurrentInstance, onServerPrefetch, isVue3, toRef, effectScope, computed } from 'vue-demi';\nimport { get, onValue, onChildAdded, onChildRemoved, onChildChanged, onChildMoved, getDatabase } from 'firebase/database';\nimport { Timestamp, GeoPoint, getDocs, onSnapshot, getDoc, getFirestore } from 'firebase/firestore';\nimport { getAuth } from 'firebase/auth';\nimport { getStorage, getDownloadURL, getMetadata, updateMetadata, uploadBytesResumable } from 'firebase/storage';\nimport 'firebase/app-check';\nimport 'firebase/app';\nconst _initialStatesMap = /* @__PURE__ */new WeakMap();\nfunction useSSRInitialState(initialState, firebaseApp) {\n  if (!_initialStatesMap.has(firebaseApp)) {\n    _initialStatesMap.set(firebaseApp, initialState || {\n      f: {},\n      r: {},\n      s: {},\n      u: {}\n    });\n  }\n  return _initialStatesMap.get(firebaseApp);\n}\nfunction getInitialValue(dataSource, ssrKey, fallbackValue, firebaseApp) {\n  if (!dataSource) return fallbackValue;\n  const [sourceType, path] = getDataSourceInfo(dataSource);\n  if (!sourceType) return fallbackValue;\n  const initialState = useSSRInitialState(void 0, firebaseApp)[sourceType] || {};\n  const key = ssrKey || path;\n  return key && key in initialState ? initialState[key] : fallbackValue;\n}\nfunction deferInitialValueSetup(dataSource, ssrKey, promise, firebaseApp) {\n  if (!dataSource) return;\n  const [sourceType, path] = getDataSourceInfo(dataSource);\n  if (!sourceType) return;\n  const initialState = useSSRInitialState(void 0, firebaseApp)[sourceType];\n  const key = ssrKey || path;\n  if (key) {\n    promise.then(value => {\n      initialState[key] = value;\n    }).catch(noop);\n    return key;\n  }\n}\nfunction getDataSourceInfo(dataSource) {\n  return isFirestoreDataReference(dataSource) || isFirestoreQuery(dataSource) ? [\"f\", dataSource.path] : isDatabaseReference(dataSource) ? [\"r\", dataSource.toString()] : isStorageReference(dataSource) ? [\"s\", dataSource.toString()] : [];\n}\nconst appPendingPromises = /* @__PURE__ */new WeakMap();\nfunction addPendingPromise(promise, dataSource, ssrKey) {\n  const app = useFirebaseApp();\n  if (!appPendingPromises.has(app)) {\n    appPendingPromises.set(app, /* @__PURE__ */new Map());\n  }\n  const pendingPromises = appPendingPromises.get(app);\n  const key = deferInitialValueSetup(dataSource, ssrKey, promise, app);\n  if (key) {\n    pendingPromises.set(key, promise);\n  } else {\n    if (process.env.NODE_ENV !== \"production\") {\n      console.warn(\"[VueFire SSR]: Could not get the path of the data source\");\n    }\n  }\n  return key ? () => pendingPromises.delete(key) : noop;\n}\nfunction usePendingPromises(app) {\n  app = app || useFirebaseApp();\n  const pendingPromises = appPendingPromises.get(app);\n  const p = pendingPromises ? Promise.all(Array.from(pendingPromises).map(([key, promise]) => promise.then(data => [key, data]))) : Promise.resolve([]);\n  appPendingPromises.delete(app);\n  return p;\n}\nfunction createRecordFromDatabaseSnapshot(snapshot) {\n  if (!snapshot.exists()) return null;\n  const value = snapshot.val();\n  return isObject(value) ? Object.defineProperty(value, \"id\", {\n    // allow destructuring without interfering without using the `id` property\n    value: snapshot.key\n  }) : {\n    // if the value is a primitive we can just return a regular object, it's easier to debug\n    // @ts-expect-error: $value doesn't exist\n    $value: value,\n    id: snapshot.key\n  };\n}\nfunction indexForKey(array, key) {\n  for (let i = 0; i < array.length; i++) {\n    if (array[i].id === key) return i;\n  }\n  return -1;\n}\nconst DEFAULT_OPTIONS$1 = {\n  reset: false,\n  serialize: createRecordFromDatabaseSnapshot,\n  wait: true\n};\nfunction bindAsObject(target, document, resolve, reject, extraOptions) {\n  const options = Object.assign({}, DEFAULT_OPTIONS$1, extraOptions);\n  let unsubscribe = noop;\n  function onValueCallback(snapshot) {\n    const value = options.serialize(snapshot);\n    target.value = value;\n    resolve(value);\n  }\n  if (options.once) {\n    get(document).then(onValueCallback).catch(reject);\n  } else {\n    unsubscribe = onValue(document, onValueCallback, reject);\n  }\n  return reset => {\n    unsubscribe();\n    if (reset) {\n      const value = typeof reset === \"function\" ? reset() : null;\n      target.value = value;\n    }\n  };\n}\nfunction bindAsArray(target, collection, resolve, reject, extraOptions) {\n  const options = Object.assign({}, DEFAULT_OPTIONS$1, extraOptions);\n  let arrayRef = options.wait ? [] : target;\n  if (!options.wait) {\n    target.value = [];\n  }\n  let removeChildAddedListener = noop;\n  let removeChildChangedListener = noop;\n  let removeChildRemovedListener = noop;\n  let removeChildMovedListener = noop;\n  let removeValueListener = noop;\n  if (options.once) {\n    get(collection).then(data => {\n      const array = [];\n      data.forEach(snapshot => {\n        array.push(options.serialize(snapshot));\n      });\n      resolve(target.value = array);\n    }).catch(reject);\n  } else {\n    removeChildAddedListener = onChildAdded(collection, (snapshot, prevKey) => {\n      const array = unref(arrayRef);\n      const index = prevKey ? indexForKey(array, prevKey) + 1 : 0;\n      array.splice(index, 0, options.serialize(snapshot));\n    }, reject);\n    removeChildRemovedListener = onChildRemoved(collection, snapshot => {\n      const array = unref(arrayRef);\n      array.splice(indexForKey(array, snapshot.key), 1);\n    }, reject);\n    removeChildChangedListener = onChildChanged(collection, snapshot => {\n      const array = unref(arrayRef);\n      array.splice(indexForKey(array, snapshot.key), 1,\n      // cannot be null because it exists\n      options.serialize(snapshot));\n    }, reject);\n    removeChildMovedListener = onChildMoved(collection, (snapshot, prevKey) => {\n      const array = unref(arrayRef);\n      const index = indexForKey(array, snapshot.key);\n      const oldRecord = array.splice(index, 1)[0];\n      const newIndex = prevKey ? indexForKey(array, prevKey) + 1 : 0;\n      array.splice(newIndex, 0, oldRecord);\n    }, reject);\n    removeValueListener = onValue(collection, () => {\n      const array = unref(arrayRef);\n      if (options.wait) {\n        target.value = array;\n        arrayRef = target;\n      }\n      resolve(array);\n      removeValueListener();\n    }, reject);\n  }\n  return reset => {\n    removeValueListener();\n    removeChildAddedListener();\n    removeChildRemovedListener();\n    removeChildChangedListener();\n    removeChildMovedListener();\n    if (reset) {\n      const value = typeof reset === \"function\" ? reset() : [];\n      target.value = value;\n    }\n  };\n}\nfunction _useDatabaseRef(reference, localOptions = {}, isList = false) {\n  let unbind = noop;\n  const options = Object.assign({}, DEFAULT_OPTIONS$1, localOptions);\n  const initialSourceValue = unref(reference);\n  const data = options.target || ref();\n  if (process.env.NODE_ENV !== \"production\") {\n    if (options.target && checkWrittenTarget(data, \"useDatabaseObject()/useDatabaseList()\")) {\n      return data;\n    }\n  }\n  if (isSSR()) {\n    options.once = true;\n  }\n  const initialValue = getInitialValue(initialSourceValue, options.ssrKey, data.value, useFirebaseApp());\n  data.value = initialValue;\n  const hasInitialValue = isList ? (initialValue || []).length > 0 : initialValue !== void 0;\n  let shouldStartAsPending = !hasInitialValue;\n  const error = ref();\n  const pending = ref(false);\n  const promise = shallowRef();\n  const hasCurrentScope = getCurrentScope();\n  let removePendingPromise = noop;\n  function bindDatabaseRef() {\n    const referenceValue = unref(reference);\n    const newPromise = new Promise((resolve, reject) => {\n      unbind(options.reset);\n      if (!referenceValue) {\n        unbind = noop;\n        return resolve(null);\n      }\n      pending.value = shouldStartAsPending;\n      shouldStartAsPending = true;\n      if (Array.isArray(data.value)) {\n        unbind = bindAsArray(data, referenceValue, resolve, reject, options);\n      } else {\n        unbind = bindAsObject(data, referenceValue, resolve, reject, options);\n      }\n    }).catch(reason => {\n      if (promise.value === newPromise) {\n        error.value = reason;\n      }\n      throw reason;\n    }).finally(() => {\n      if (promise.value === newPromise) {\n        pending.value = false;\n      }\n    });\n    promise.value = newPromise;\n  }\n  let stopWatcher = noop;\n  if (isRef(reference)) {\n    stopWatcher = watch(reference, bindDatabaseRef);\n  }\n  bindDatabaseRef();\n  if (initialSourceValue) {\n    removePendingPromise = addPendingPromise(promise.value, initialSourceValue);\n  }\n  if (hasCurrentScope) {\n    onScopeDispose(stop);\n    if (getCurrentInstance()) {\n      onServerPrefetch(() => promise.value);\n    }\n  }\n  function stop(reset = options.reset) {\n    stopWatcher();\n    removePendingPromise();\n    unbind(reset);\n  }\n  return Object.defineProperties(data, {\n    // allow destructuring without interfering with the ref itself\n    data: {\n      get: () => data\n    },\n    error: {\n      get: () => error\n    },\n    pending: {\n      get: () => pending\n    },\n    promise: {\n      get: () => promise\n    },\n    stop: {\n      get: () => stop\n    }\n  });\n}\nfunction useDatabaseList(reference, options) {\n  const data = ref([]);\n  return _useDatabaseRef(reference, {\n    target: data,\n    ...options\n  }, true);\n}\nconst useList = useDatabaseList;\nfunction useDatabaseObject(reference, options) {\n  const data = ref();\n  return _useDatabaseRef(reference, {\n    target: data,\n    ...options\n  });\n}\nconst useObject = useDatabaseObject;\nfunction useDatabase(name) {\n  return getDatabase(useFirebaseApp(name));\n}\nconst firestoreDefaultConverter = {\n  toFirestore(data) {\n    return data;\n  },\n  fromFirestore(snapshot, options) {\n    return snapshot.exists() ? Object.defineProperties(snapshot.data(options), {\n      id: {\n        value: snapshot.id\n      }\n      // TODO: check if worth adding or should be through an option\n      // It could also be an example in the docs about converters\n      // $meta: {\n      //   value: snapshot.metadata,\n      // },\n      // $ref: { get: () => snapshot.ref },\n    }) : null;\n  }\n};\nfunction extractRefs(doc, oldDoc, subs, options) {\n  if (!isPOJO(doc)) return [doc, {}];\n  const dataAndRefs = [{}, {}];\n  const subsByPath = Object.keys(subs).reduce((resultSubs, subKey) => {\n    const sub = subs[subKey];\n    resultSubs[sub.path] = sub.data();\n    return resultSubs;\n  }, {});\n  function recursiveExtract(doc2, oldDoc2, path, result) {\n    oldDoc2 = oldDoc2 || {};\n    const [data, refs] = result;\n    Object.getOwnPropertyNames(doc2).forEach(propertyName => {\n      const descriptor = Object.getOwnPropertyDescriptor(doc2, propertyName);\n      if (descriptor && !descriptor.enumerable) {\n        Object.defineProperty(data, propertyName, descriptor);\n      }\n    });\n    for (const key in doc2) {\n      const ref = doc2[key];\n      if (\n      // primitives\n      ref == null ||\n      // TODO: check and remove\n      // Firestore < 4.13\n      ref instanceof Date || ref instanceof Timestamp || ref instanceof GeoPoint) {\n        data[key] = ref;\n      } else if (isDocumentRef(ref)) {\n        const refSubKey = path + key;\n        data[key] =\n        // if the ref was already bound, keep the same object\n        // otherwise set the path as a string so it can be bound later\n        // https://github.com/vuejs/vuefire/issues/831\n        // https://github.com/vuejs/vuefire/pull/1223\n        refSubKey in subs ? oldDoc2[key] : ref.path;\n        refs[refSubKey] = ref.converter ? ref : ref.withConverter(options.converter);\n      } else if (Array.isArray(ref)) {\n        data[key] = Array(ref.length);\n        for (let i = 0; i < ref.length; i++) {\n          const newRef = ref[i];\n          if (newRef && newRef.path in subsByPath) data[key][i] = subsByPath[newRef.path];\n        }\n        recursiveExtract(ref, oldDoc2[key] || data[key], path + key + \".\", [data[key], refs]);\n      } else if (isObject(ref)) {\n        data[key] = {};\n        recursiveExtract(ref, oldDoc2[key], path + key + \".\", [data[key], refs]);\n      } else {\n        data[key] = ref;\n      }\n    }\n  }\n  recursiveExtract(doc, oldDoc, \"\", dataAndRefs);\n  return dataAndRefs;\n}\nconst DEFAULT_OPTIONS = {\n  reset: false,\n  wait: true,\n  maxRefDepth: 2,\n  converter: firestoreDefaultConverter,\n  snapshotOptions: {\n    serverTimestamps: \"estimate\"\n  }\n};\nfunction unsubscribeAll(subs) {\n  for (const sub in subs) {\n    subs[sub].unsub();\n  }\n}\nfunction updateDataFromDocumentSnapshot(options, target, path, snapshot, subs, ops, depth, resolve, reject) {\n  const [data, refs] = extractRefs(\n  // Pass snapshot options\n  // @ts-expect-error: FIXME: use better types\n  snapshot.data(options.snapshotOptions), walkGet(target, path), subs, options);\n  ops.set(target, path, data);\n  subscribeToRefs(options, target, path, subs, refs, ops, depth, resolve, reject);\n}\nfunction subscribeToDocument({\n  ref: ref2,\n  target,\n  path,\n  depth,\n  resolve,\n  reject,\n  ops\n}, options) {\n  const subs = /* @__PURE__ */Object.create(null);\n  let unbind = noop;\n  if (options.once) {\n    getDoc(ref2).then(snapshot => {\n      if (snapshot.exists()) {\n        updateDataFromDocumentSnapshot(options, target, path, snapshot, subs, ops, depth, resolve, reject);\n      } else {\n        ops.set(target, path, null);\n        resolve();\n      }\n    }).catch(reject);\n  } else {\n    unbind = onSnapshot(ref2, snapshot => {\n      if (snapshot.exists()) {\n        updateDataFromDocumentSnapshot(options, target, path, snapshot, subs, ops, depth, resolve, reject);\n      } else {\n        ops.set(target, path, null);\n        resolve();\n      }\n    }, reject);\n  }\n  return () => {\n    unbind();\n    unsubscribeAll(subs);\n  };\n}\nfunction subscribeToRefs(options, target, path, subs, refs, ops, depth, resolve, reject) {\n  const refKeys = Object.keys(refs);\n  const missingKeys = Object.keys(subs).filter(refKey => refKeys.indexOf(refKey) < 0);\n  missingKeys.forEach(refKey => {\n    subs[refKey].unsub();\n    delete subs[refKey];\n  });\n  if (!refKeys.length || ++depth > options.maxRefDepth) return resolve(path);\n  let resolvedCount = 0;\n  const totalToResolve = refKeys.length;\n  const validResolves = /* @__PURE__ */Object.create(null);\n  function deepResolve(key) {\n    if (key in validResolves) {\n      if (++resolvedCount >= totalToResolve) resolve(path);\n    }\n  }\n  refKeys.forEach(refKey => {\n    const sub = subs[refKey];\n    const ref2 = refs[refKey];\n    const docPath = `${path}.${refKey}`;\n    validResolves[docPath] = true;\n    if (sub) {\n      if (sub.path !== ref2.path) sub.unsub();else return;\n    }\n    subs[refKey] = {\n      data: () => walkGet(target, docPath),\n      unsub: subscribeToDocument({\n        ref: ref2,\n        target,\n        path: docPath,\n        depth,\n        ops,\n        resolve: deepResolve.bind(null, docPath),\n        reject\n      }, options),\n      path: ref2.path\n    };\n  });\n}\nfunction bindCollection(target, collection, ops, resolve, reject, extraOptions) {\n  const options = Object.assign({}, DEFAULT_OPTIONS, extraOptions);\n  const {\n    snapshotListenOptions,\n    snapshotOptions,\n    wait,\n    once\n  } = options;\n  const key = \"value\";\n  let arrayRef = ref(wait ? [] : target.value);\n  if (!wait) ops.set(target, key, []);\n  const originalResolve = resolve;\n  let isResolved;\n  let stopOnSnapshot = noop;\n  const arraySubs = [];\n  const change = {\n    added: ({\n      newIndex,\n      doc\n    }) => {\n      arraySubs.splice(newIndex, 0, /* @__PURE__ */Object.create(null));\n      const subs = arraySubs[newIndex];\n      const [data, refs] = extractRefs(\n      // @ts-expect-error: FIXME: wrong cast, needs better types\n      doc.data(snapshotOptions), void 0, subs, options);\n      ops.add(unref(arrayRef), newIndex, data);\n      subscribeToRefs(options, arrayRef, `${key}.${newIndex}`, subs, refs, ops, 0, resolve.bind(null, doc), reject);\n    },\n    modified: ({\n      oldIndex,\n      newIndex,\n      doc\n    }) => {\n      const array = unref(arrayRef);\n      const subs = arraySubs[oldIndex];\n      const oldData = array[oldIndex];\n      const [data, refs] = extractRefs(\n      // @ts-expect-error: FIXME: Better types\n      doc.data(snapshotOptions), oldData, subs, options);\n      arraySubs.splice(newIndex, 0, subs);\n      ops.remove(array, oldIndex);\n      ops.add(array, newIndex, data);\n      subscribeToRefs(options, arrayRef, `${key}.${newIndex}`, subs, refs, ops, 0, resolve, reject);\n    },\n    removed: ({\n      oldIndex\n    }) => {\n      const array = unref(arrayRef);\n      ops.remove(array, oldIndex);\n      unsubscribeAll(arraySubs.splice(oldIndex, 1)[0]);\n    }\n  };\n  function onSnapshotCallback(snapshot) {\n    const docChanges = snapshot.docChanges(snapshotListenOptions);\n    if (!isResolved && docChanges.length) {\n      isResolved = true;\n      let count = 0;\n      const expectedItems = docChanges.length;\n      const validDocs = /* @__PURE__ */Object.create(null);\n      for (let i = 0; i < expectedItems; i++) {\n        validDocs[docChanges[i].doc.id] = true;\n      }\n      resolve = data => {\n        if (data && data.id in validDocs) {\n          if (++count >= expectedItems) {\n            if (wait) {\n              ops.set(target, key, unref(arrayRef));\n              arrayRef = target;\n            }\n            originalResolve(unref(arrayRef));\n            resolve = noop;\n          }\n        }\n      };\n    }\n    docChanges.forEach(c => {\n      change[c.type](c);\n    });\n    if (!docChanges.length) {\n      if (wait) {\n        ops.set(target, key, unref(arrayRef));\n        arrayRef = target;\n      }\n      resolve(unref(arrayRef));\n    }\n  }\n  if (once) {\n    getDocs(collection).then(onSnapshotCallback).catch(reject);\n  } else {\n    stopOnSnapshot = onSnapshot(collection, onSnapshotCallback, reject);\n  }\n  return reset => {\n    stopOnSnapshot();\n    if (reset) {\n      const value = typeof reset === \"function\" ? reset() : [];\n      ops.set(target, key, value);\n    }\n    arraySubs.forEach(unsubscribeAll);\n  };\n}\nfunction bindDocument(target, document, ops, resolve, reject, extraOptions) {\n  const options = Object.assign({}, DEFAULT_OPTIONS, extraOptions);\n  const key = \"value\";\n  const subs = /* @__PURE__ */Object.create(null);\n  resolve = callOnceWithArg(resolve, () => walkGet(target, key));\n  let stopOnSnapshot = noop;\n  function onSnapshotCallback(snapshot) {\n    if (snapshot.exists()) {\n      updateDataFromDocumentSnapshot(options, target, key, snapshot, subs, ops, 0, resolve, reject);\n    } else {\n      ops.set(target, key, null);\n      resolve(null);\n    }\n  }\n  if (options.once) {\n    getDoc(document).then(onSnapshotCallback).catch(reject);\n  } else {\n    stopOnSnapshot = onSnapshot(document, onSnapshotCallback, reject);\n  }\n  return reset => {\n    stopOnSnapshot();\n    if (reset) {\n      const value = typeof reset === \"function\" ? reset() : null;\n      ops.set(target, key, value);\n    }\n    unsubscribeAll(subs);\n  };\n}\nfunction _useFirestoreRef(docOrCollectionRef, localOptions) {\n  let unbind = noop;\n  const options = Object.assign({}, DEFAULT_OPTIONS, localOptions);\n  const initialSourceValue = unref(docOrCollectionRef);\n  const data = options.target || ref();\n  if (process.env.NODE_ENV !== \"production\") {\n    if (options.target && checkWrittenTarget(data, \"useDocument()/useCollection()\")) {\n      return data;\n    }\n  }\n  if (isSSR()) {\n    options.once = true;\n  }\n  const initialValue = getInitialValue(initialSourceValue, options.ssrKey, data.value, useFirebaseApp());\n  data.value = initialValue;\n  const hasInitialValue = isCollectionRef(initialSourceValue) ? (initialValue || []).length > 0 : initialValue !== void 0;\n  let shouldStartAsPending = !hasInitialValue;\n  const pending = ref(false);\n  const error = ref();\n  const promise = shallowRef();\n  const hasCurrentScope = getCurrentScope();\n  let removePendingPromise = noop;\n  function bindFirestoreRef() {\n    let docRefValue = unref(docOrCollectionRef);\n    const newPromise = new Promise((resolve, reject) => {\n      unbind(options.reset);\n      if (!docRefValue) {\n        unbind = noop;\n        return resolve(null);\n      }\n      pending.value = shouldStartAsPending;\n      shouldStartAsPending = true;\n      if (!docRefValue.converter) {\n        docRefValue = docRefValue.withConverter(\n        // @ts-expect-error: seems like a ts error\n        options.converter);\n      }\n      unbind = (isDocumentRef(docRefValue) ? bindDocument : bindCollection)(\n      // @ts-expect-error: cannot type with the ternary\n      data, docRefValue, ops, resolve, reject, options);\n    }).catch(reason => {\n      if (promise.value === newPromise) {\n        error.value = reason;\n      }\n      return Promise.reject(reason);\n    }).finally(() => {\n      if (promise.value === newPromise) {\n        pending.value = false;\n      }\n    });\n    promise.value = newPromise;\n  }\n  let stopWatcher = noop;\n  if (isRef(docOrCollectionRef)) {\n    stopWatcher = watch(docOrCollectionRef, bindFirestoreRef);\n  }\n  bindFirestoreRef();\n  if (initialSourceValue) {\n    removePendingPromise = addPendingPromise(promise.value, initialSourceValue, options.ssrKey);\n  }\n  if (getCurrentInstance()) {\n    onServerPrefetch(() => promise.value);\n  }\n  if (hasCurrentScope) {\n    onScopeDispose(stop);\n  }\n  function stop(reset = options.reset) {\n    stopWatcher();\n    removePendingPromise();\n    unbind(reset);\n  }\n  return Object.defineProperties(data, {\n    error: {\n      get: () => error\n    },\n    data: {\n      get: () => data\n    },\n    pending: {\n      get: () => pending\n    },\n    promise: {\n      get: () => promise\n    },\n    stop: {\n      get: () => stop\n    }\n  });\n}\nconst ops = {\n  set: (target, key, value) => walkSet(target, key, value),\n  add: (array, index, data) => array.splice(index, 0, data),\n  remove: (array, index) => array.splice(index, 1)\n};\nfunction useCollection(collectionRef, options) {\n  return _useFirestoreRef(collectionRef, {\n    target: ref([]),\n    ...options\n  });\n}\nfunction useDocument(documentRef, options) {\n  return _useFirestoreRef(documentRef, options);\n}\nfunction useFirestore(name) {\n  return getFirestore(useFirebaseApp(name));\n}\nconst databaseUnbinds = /* @__PURE__ */new WeakMap();\nfunction internalUnbind$1(key, unbinds, reset) {\n  if (unbinds && unbinds[key]) {\n    unbinds[key](reset);\n    delete unbinds[key];\n  }\n}\nconst databasePluginDefaults = {\n  bindName: \"$databaseBind\",\n  unbindName: \"$databaseUnbind\"\n};\nfunction databasePlugin(app, pluginOptions, firebaseApp) {\n  const globalOptions = Object.assign({}, databasePluginDefaults, pluginOptions);\n  const {\n    bindName,\n    unbindName\n  } = globalOptions;\n  const GlobalTarget = isVue3 ? app.config.globalProperties : app.prototype;\n  GlobalTarget[unbindName] = function databaseUnbind(key, reset) {\n    internalUnbind$1(key, databaseUnbinds.get(this), reset);\n    delete this.$firebaseRefs[key];\n  };\n  GlobalTarget[bindName] = function databaseBind(key, source, userOptions) {\n    const options = Object.assign({}, globalOptions, userOptions);\n    const target = toRef(this.$data, key);\n    if (!databaseUnbinds.has(this)) {\n      databaseUnbinds.set(this, {});\n    }\n    const unbinds = databaseUnbinds.get(this);\n    if (unbinds[key]) {\n      unbinds[key](options.reset);\n    }\n    if (pluginOptions) {\n      if (!pluginOptions.bindName) {\n        GlobalTarget[\"$rtdbBind\"] = GlobalTarget[bindName];\n      }\n      if (!pluginOptions.unbindName) {\n        GlobalTarget[\"$rtdbUnbind\"] = GlobalTarget[unbindName];\n      }\n    }\n    const scope = getGlobalScope(firebaseApp || useFirebaseApp(), app).run(() => effectScope());\n    const {\n      promise,\n      stop: _unbind\n    } = scope.run(() => _useDatabaseRef(source, {\n      target,\n      ...options\n    }));\n    const unbind = reset => {\n      _unbind(reset);\n      scope.stop();\n    };\n    unbinds[key] = unbind;\n    this.$firebaseRefs[key] = source.ref;\n    return promise.value;\n  };\n  app.mixin({\n    beforeCreate() {\n      this.$firebaseRefs = /* @__PURE__ */Object.create(null);\n    },\n    created() {\n      let bindings = this.$options.firebase;\n      if (typeof bindings === \"function\") {\n        bindings = bindings.call(this);\n      }\n      if (!bindings) return;\n      for (const key in bindings) {\n        this[bindName](\n        // ts\n        key, bindings[key], globalOptions);\n      }\n    },\n    beforeUnmount() {\n      const unbinds = databaseUnbinds.get(this);\n      if (unbinds) {\n        for (const key in unbinds) {\n          unbinds[key]();\n        }\n      }\n      this.$firebaseRefs = null;\n    }\n  });\n}\nfunction VueFireDatabaseOptionsAPI(pluginOptions) {\n  return (firebaseApp, app) => {\n    return databasePlugin(app, pluginOptions, firebaseApp);\n  };\n}\nconst firestoreUnbinds = /* @__PURE__ */new WeakMap();\nfunction internalUnbind(key, unbinds, reset) {\n  if (unbinds && unbinds[key]) {\n    unbinds[key](reset);\n    delete unbinds[key];\n  }\n}\nconst firestorePluginDefaults = {\n  bindName: \"$firestoreBind\",\n  unbindName: \"$firestoreUnbind\"\n};\nconst firestorePlugin = function firestorePlugin2(app, pluginOptions, firebaseApp) {\n  const globalOptions = Object.assign({}, firestorePluginDefaults, pluginOptions);\n  const {\n    bindName,\n    unbindName\n  } = globalOptions;\n  const GlobalTarget = isVue3 ? app.config.globalProperties : app.prototype;\n  GlobalTarget[unbindName] = function firestoreUnbind(key, reset) {\n    internalUnbind(key, firestoreUnbinds.get(this), reset);\n    delete this.$firestoreRefs[key];\n  };\n  GlobalTarget[bindName] = function firestoreBind(key, docOrCollectionRef, userOptions) {\n    const options = Object.assign({}, globalOptions, userOptions);\n    const target = toRef(this.$data, key);\n    if (!firestoreUnbinds.has(this)) {\n      firestoreUnbinds.set(this, {});\n    }\n    const unbinds = firestoreUnbinds.get(this);\n    if (unbinds[key]) {\n      unbinds[key](options.reset);\n    }\n    const scope = getGlobalScope(firebaseApp || useFirebaseApp(), app).run(() => effectScope());\n    const {\n      promise,\n      stop: _unbind\n    } = scope.run(() => _useFirestoreRef(docOrCollectionRef, {\n      target,\n      ...options\n    }));\n    const unbind = reset => {\n      _unbind(reset);\n      scope.stop();\n    };\n    unbinds[key] = unbind;\n    this.$firestoreRefs[key] =\n    // ts\n    docOrCollectionRef;\n    return promise.value;\n  };\n  app.mixin({\n    beforeCreate() {\n      this.$firestoreRefs = /* @__PURE__ */Object.create(null);\n    },\n    created() {\n      const {\n        firestore\n      } = this.$options;\n      const refs = typeof firestore === \"function\" ? firestore.call(this) : firestore;\n      if (!refs) return;\n      for (const key in refs) {\n        this[bindName](key,\n        // @ts-expect-error: FIXME: there is probably a wrong type in global properties\n        refs[key], globalOptions);\n      }\n    },\n    beforeUnmount() {\n      const unbinds = firestoreUnbinds.get(this);\n      if (unbinds) {\n        for (const subKey in unbinds) {\n          unbinds[subKey]();\n        }\n      }\n      this.$firestoreRefs = null;\n    }\n  });\n};\nfunction VueFireFirestoreOptionsAPI(pluginOptions) {\n  return (firebaseApp, app) => {\n    return firestorePlugin(app, pluginOptions, firebaseApp);\n  };\n}\nfunction VueFireAuth(initialUser) {\n  return (firebaseApp, app) => {\n    const user = getGlobalScope(firebaseApp, app).run(() => ref(initialUser));\n    authUserMap.set(firebaseApp, user);\n    setupOnAuthStateChanged(user, firebaseApp);\n  };\n}\nfunction useFirebaseAuth(name) {\n  return isClient ? getAuth(useFirebaseApp(name)) : null;\n}\nfunction useFirebaseStorage(name) {\n  return getStorage(useFirebaseApp(name));\n}\nfunction useStorageFileUrl(storageRef) {\n  const initialSourceValue = unref(storageRef);\n  const url = ref();\n  url.value = getInitialValue(initialSourceValue, void 0, url.value, useFirebaseApp());\n  const promise = shallowRef(Promise.resolve(null));\n  let removePendingPromise = noop;\n  function refresh() {\n    const storageSource = unref(storageRef);\n    if (storageSource) {\n      promise.value = getDownloadURL(storageSource).then(downloadUrl => url.value = downloadUrl).catch(() => null);\n    } else {\n      promise.value = Promise.resolve(url.value = null);\n    }\n    return promise.value;\n  }\n  refresh();\n  if (isRef(storageRef)) {\n    watch(storageRef, refresh);\n  }\n  if (initialSourceValue) {\n    removePendingPromise = addPendingPromise(promise.value, initialSourceValue);\n  }\n  if (getCurrentScope()) {\n    onScopeDispose(removePendingPromise);\n  }\n  if (getCurrentInstance()) {\n    onServerPrefetch(() => promise.value);\n  }\n  return {\n    url,\n    refresh,\n    promise\n  };\n}\nfunction useStorageFileMetadata(storageRef) {\n  const initialSourceValue = unref(storageRef);\n  const metadata = shallowRef();\n  if (initialSourceValue) {\n    metadata.value = getInitialValue(initialSourceValue,\n    // 'm ' is a prefix to differentiate from urls since both are stored in the same object\n    \"m \" + initialSourceValue.toString(), metadata.value, useFirebaseApp());\n  }\n  const promise = shallowRef(Promise.resolve(null));\n  let removePendingPromise = noop;\n  function refresh() {\n    const storageSource = unref(storageRef);\n    if (storageSource) {\n      promise.value = getMetadata(storageSource).then(data => metadata.value = data).catch(() => null);\n    } else {\n      promise.value = Promise.resolve(metadata.value = null);\n    }\n    return promise.value;\n  }\n  function update(newMetadata) {\n    const storageSource = unref(storageRef);\n    if (storageSource) {\n      promise.value = updateMetadata(storageSource, newMetadata).then(newData => {\n        return metadata.value = newData;\n      });\n    } else if (process.env.NODE_ENV !== \"production\") {\n      console.warn('[VueFire]: \"update()\" called with no storage source.');\n    }\n    return promise.value;\n  }\n  refresh();\n  if (isRef(storageRef)) {\n    watch(storageRef, refresh);\n  }\n  if (initialSourceValue) {\n    removePendingPromise = addPendingPromise(promise.value, initialSourceValue);\n  }\n  if (getCurrentScope()) {\n    onScopeDispose(removePendingPromise);\n  }\n  if (getCurrentInstance()) {\n    onServerPrefetch(() => promise.value);\n  }\n  return {\n    metadata,\n    update,\n    refresh,\n    promise\n  };\n}\nfunction useStorageFile(storageRef) {\n  const {\n    url,\n    refresh: refreshUrl\n  } = useStorageFileUrl(storageRef);\n  const {\n    metadata,\n    update: updateMetadata2,\n    refresh: refreshMetadata\n  } = useStorageFileMetadata(storageRef);\n  const uploadTask = shallowRef();\n  const snapshot = shallowRef();\n  const uploadError = shallowRef();\n  const uploadProgress = computed(() => {\n    const snap = unref(snapshot);\n    return snap ? snap.bytesTransferred / snap.totalBytes : null;\n  });\n  let unsub = noop;\n  function upload(newData, newMetadata) {\n    const storageSource = unref(storageRef);\n    const currentTask = unref(uploadTask);\n    if (currentTask) {\n      currentTask.cancel();\n    }\n    uploadError.value = null;\n    snapshot.value = null;\n    uploadTask.value = null;\n    url.value = null;\n    metadata.value = null;\n    unsub();\n    if (storageSource) {\n      const newTask = uploadBytesResumable(storageSource, newData, newMetadata);\n      uploadTask.value = newTask;\n      snapshot.value = newTask.snapshot;\n      unsub = newTask.on(\"state_changed\", newSnapshot => {\n        snapshot.value = newSnapshot;\n      });\n      return newTask.then(finalSnapshot => {\n        metadata.value = finalSnapshot.metadata;\n        refreshUrl();\n      }).catch(err => {\n        uploadError.value = err;\n        return Promise.reject(err);\n      }).finally(() => {\n        unsub();\n        uploadTask.value = null;\n      });\n    }\n  }\n  function refresh() {\n    return Promise.all([refreshUrl(), refreshMetadata()]);\n  }\n  if (isRef(storageRef)) {\n    watch(storageRef, storageSource => {\n      if (!storageSource) {\n        if (uploadTask.value) {\n          unsub();\n          uploadTask.value.cancel();\n        }\n        uploadTask.value = null;\n        snapshot.value = null;\n      }\n      refresh();\n    });\n  }\n  if (getCurrentScope()) {\n    onScopeDispose(unsub);\n  }\n  return {\n    url,\n    metadata,\n    snapshot,\n    uploadTask,\n    uploadError,\n    uploadProgress,\n    upload,\n    updateMetadata: updateMetadata2,\n    refresh\n    // promise,\n  };\n}\n\nconst useStorage = useFirebaseStorage;\nconst useStorageUrl = useStorageFileUrl;\nconst useStorageMetadata = useStorageFileMetadata;\nconst useStorageObject = useStorageFile;\nfunction VueFire(app, {\n  firebaseApp,\n  modules = []\n}) {\n  app.provide(_FirebaseAppInjectionKey, firebaseApp);\n  for (const firebaseModule of modules) {\n    app.use(firebaseModule.bind(null, firebaseApp));\n  }\n}\nexport { VueFire, VueFireAuth, VueFireDatabaseOptionsAPI, VueFireFirestoreOptionsAPI, databasePlugin, firestoreDefaultConverter, firestorePlugin, DEFAULT_OPTIONS$1 as globalDatabaseOptions, DEFAULT_OPTIONS as globalFirestoreOptions, databasePlugin as rtdbPlugin, useCollection, useDatabase, useDatabaseList, useDatabaseObject, useDocument, useFirebaseApp, useFirebaseAuth, useFirebaseStorage, useFirestore, useList, useObject, usePendingPromises, useSSRInitialState, useStorage, useStorageFile, useStorageFileMetadata, useStorageFileUrl, useStorageMetadata, useStorageObject, useStorageUrl };","map":{"version":3,"names":["i","isFirestoreDataReference","a","isFirestoreQuery","b","isDatabaseReference","c","isStorageReference","n","noop","u","useFirebaseApp","d","isObject","e","checkWrittenTarget","f","isSSR","g","isPOJO","h","isDocumentRef","w","walkGet","j","callOnceWithArg","k","isCollectionRef","l","walkSet","m","getGlobalScope","o","authUserMap","s","setupOnAuthStateChanged","p","isClient","_","_FirebaseAppInjectionKey","V","VueFireAppCheck","t","getCurrentUser","v","updateCurrentUserProfile","y","useAppCheck","x","useAppCheckToken","q","useCurrentUser","r","useIsCurrentUserLoaded","unref","ref","shallowRef","getCurrentScope","isRef","watch","onScopeDispose","getCurrentInstance","onServerPrefetch","isVue3","toRef","effectScope","computed","get","onValue","onChildAdded","onChildRemoved","onChildChanged","onChildMoved","getDatabase","Timestamp","GeoPoint","getDocs","onSnapshot","getDoc","getFirestore","getAuth","getStorage","getDownloadURL","getMetadata","updateMetadata","uploadBytesResumable","_initialStatesMap","WeakMap","useSSRInitialState","initialState","firebaseApp","has","set","getInitialValue","dataSource","ssrKey","fallbackValue","sourceType","path","getDataSourceInfo","key","deferInitialValueSetup","promise","then","value","catch","toString","appPendingPromises","addPendingPromise","app","Map","pendingPromises","process","env","NODE_ENV","console","warn","delete","usePendingPromises","Promise","all","Array","from","map","data","resolve","createRecordFromDatabaseSnapshot","snapshot","exists","val","Object","defineProperty","$value","id","indexForKey","array","length","DEFAULT_OPTIONS$1","reset","serialize","wait","bindAsObject","target","document","reject","extraOptions","options","assign","unsubscribe","onValueCallback","once","bindAsArray","collection","arrayRef","removeChildAddedListener","removeChildChangedListener","removeChildRemovedListener","removeChildMovedListener","removeValueListener","forEach","push","prevKey","index","splice","oldRecord","newIndex","_useDatabaseRef","reference","localOptions","isList","unbind","initialSourceValue","initialValue","hasInitialValue","shouldStartAsPending","error","pending","hasCurrentScope","removePendingPromise","bindDatabaseRef","referenceValue","newPromise","isArray","reason","finally","stopWatcher","stop","defineProperties","useDatabaseList","useList","useDatabaseObject","useObject","useDatabase","name","firestoreDefaultConverter","toFirestore","fromFirestore","extractRefs","doc","oldDoc","subs","dataAndRefs","subsByPath","keys","reduce","resultSubs","subKey","sub","recursiveExtract","doc2","oldDoc2","result","refs","getOwnPropertyNames","propertyName","descriptor","getOwnPropertyDescriptor","enumerable","Date","refSubKey","converter","withConverter","newRef","DEFAULT_OPTIONS","maxRefDepth","snapshotOptions","serverTimestamps","unsubscribeAll","unsub","updateDataFromDocumentSnapshot","ops","depth","subscribeToRefs","subscribeToDocument","ref2","create","refKeys","missingKeys","filter","refKey","indexOf","resolvedCount","totalToResolve","validResolves","deepResolve","docPath","bind","bindCollection","snapshotListenOptions","originalResolve","isResolved","stopOnSnapshot","arraySubs","change","added","add","modified","oldIndex","oldData","remove","removed","onSnapshotCallback","docChanges","count","expectedItems","validDocs","type","bindDocument","_useFirestoreRef","docOrCollectionRef","bindFirestoreRef","docRefValue","useCollection","collectionRef","useDocument","documentRef","useFirestore","databaseUnbinds","internalUnbind$1","unbinds","databasePluginDefaults","bindName","unbindName","databasePlugin","pluginOptions","globalOptions","GlobalTarget","config","globalProperties","prototype","databaseUnbind","$firebaseRefs","databaseBind","source","userOptions","$data","scope","run","_unbind","mixin","beforeCreate","created","bindings","$options","firebase","call","beforeUnmount","VueFireDatabaseOptionsAPI","firestoreUnbinds","internalUnbind","firestorePluginDefaults","firestorePlugin","firestorePlugin2","firestoreUnbind","$firestoreRefs","firestoreBind","firestore","VueFireFirestoreOptionsAPI","VueFireAuth","initialUser","user","useFirebaseAuth","useFirebaseStorage","useStorageFileUrl","storageRef","url","refresh","storageSource","downloadUrl","useStorageFileMetadata","metadata","update","newMetadata","newData","useStorageFile","refreshUrl","updateMetadata2","refreshMetadata","uploadTask","uploadError","uploadProgress","snap","bytesTransferred","totalBytes","upload","currentTask","cancel","newTask","on","newSnapshot","finalSnapshot","err","useStorage","useStorageUrl","useStorageMetadata","useStorageObject","VueFire","modules","provide","firebaseModule","use","globalDatabaseOptions","globalFirestoreOptions","rtdbPlugin"],"sources":["C:/Users/ALFIAN WAHYU/Documents/Coding/Latihan_Coding/Vue_js/com.alfian.09040620045/node_modules/vuefire/dist/index.mjs"],"sourcesContent":["import { i as isFirestoreDataReference, a as isFirestoreQuery, b as isDatabaseReference, c as isStorageReference, n as noop, u as useFirebaseApp, d as isObject, e as checkWrittenTarget, f as isSSR, g as isPOJO, h as isDocumentRef, w as walkGet, j as callOnceWithArg, k as isCollectionRef, l as walkSet, m as getGlobalScope, o as authUserMap, s as setupOnAuthStateChanged, p as isClient, _ as _FirebaseAppInjectionKey } from './shared/vuefire.7f889637.mjs';\nexport { V as VueFireAppCheck, t as getCurrentUser, v as updateCurrentUserProfile, y as useAppCheck, x as useAppCheckToken, q as useCurrentUser, r as useIsCurrentUserLoaded } from './shared/vuefire.7f889637.mjs';\nimport { unref, ref, shallowRef, getCurrentScope, isRef, watch, onScopeDispose, getCurrentInstance, onServerPrefetch, isVue3, toRef, effectScope, computed } from 'vue-demi';\nimport { get, onValue, onChildAdded, onChildRemoved, onChildChanged, onChildMoved, getDatabase } from 'firebase/database';\nimport { Timestamp, GeoPoint, getDocs, onSnapshot, getDoc, getFirestore } from 'firebase/firestore';\nimport { getAuth } from 'firebase/auth';\nimport { getStorage, getDownloadURL, getMetadata, updateMetadata, uploadBytesResumable } from 'firebase/storage';\nimport 'firebase/app-check';\nimport 'firebase/app';\n\nconst _initialStatesMap = /* @__PURE__ */ new WeakMap();\nfunction useSSRInitialState(initialState, firebaseApp) {\n  if (!_initialStatesMap.has(firebaseApp)) {\n    _initialStatesMap.set(\n      firebaseApp,\n      initialState || { f: {}, r: {}, s: {}, u: {} }\n    );\n  }\n  return _initialStatesMap.get(firebaseApp);\n}\nfunction getInitialValue(dataSource, ssrKey, fallbackValue, firebaseApp) {\n  if (!dataSource)\n    return fallbackValue;\n  const [sourceType, path] = getDataSourceInfo(dataSource);\n  if (!sourceType)\n    return fallbackValue;\n  const initialState = useSSRInitialState(void 0, firebaseApp)[sourceType] || {};\n  const key = ssrKey || path;\n  return key && key in initialState ? initialState[key] : fallbackValue;\n}\nfunction deferInitialValueSetup(dataSource, ssrKey, promise, firebaseApp) {\n  if (!dataSource)\n    return;\n  const [sourceType, path] = getDataSourceInfo(dataSource);\n  if (!sourceType)\n    return;\n  const initialState = useSSRInitialState(\n    void 0,\n    firebaseApp\n  )[sourceType];\n  const key = ssrKey || path;\n  if (key) {\n    promise.then((value) => {\n      initialState[key] = value;\n    }).catch(noop);\n    return key;\n  }\n}\nfunction getDataSourceInfo(dataSource) {\n  return isFirestoreDataReference(dataSource) || isFirestoreQuery(dataSource) ? [\"f\", dataSource.path] : isDatabaseReference(dataSource) ? [\"r\", dataSource.toString()] : isStorageReference(dataSource) ? [\"s\", dataSource.toString()] : [];\n}\n\nconst appPendingPromises = /* @__PURE__ */ new WeakMap();\nfunction addPendingPromise(promise, dataSource, ssrKey) {\n  const app = useFirebaseApp();\n  if (!appPendingPromises.has(app)) {\n    appPendingPromises.set(app, /* @__PURE__ */ new Map());\n  }\n  const pendingPromises = appPendingPromises.get(app);\n  const key = deferInitialValueSetup(dataSource, ssrKey, promise, app);\n  if (key) {\n    pendingPromises.set(key, promise);\n  } else {\n    if (process.env.NODE_ENV !== \"production\") {\n      console.warn(\"[VueFire SSR]: Could not get the path of the data source\");\n    }\n  }\n  return key ? () => pendingPromises.delete(key) : noop;\n}\nfunction usePendingPromises(app) {\n  app = app || useFirebaseApp();\n  const pendingPromises = appPendingPromises.get(app);\n  const p = pendingPromises ? Promise.all(\n    Array.from(pendingPromises).map(\n      ([key, promise]) => promise.then((data) => [key, data])\n    )\n  ) : Promise.resolve([]);\n  appPendingPromises.delete(app);\n  return p;\n}\n\nfunction createRecordFromDatabaseSnapshot(snapshot) {\n  if (!snapshot.exists())\n    return null;\n  const value = snapshot.val();\n  return isObject(value) ? Object.defineProperty(value, \"id\", {\n    // allow destructuring without interfering without using the `id` property\n    value: snapshot.key\n  }) : {\n    // if the value is a primitive we can just return a regular object, it's easier to debug\n    // @ts-expect-error: $value doesn't exist\n    $value: value,\n    id: snapshot.key\n  };\n}\nfunction indexForKey(array, key) {\n  for (let i = 0; i < array.length; i++) {\n    if (array[i].id === key)\n      return i;\n  }\n  return -1;\n}\n\nconst DEFAULT_OPTIONS$1 = {\n  reset: false,\n  serialize: createRecordFromDatabaseSnapshot,\n  wait: true\n};\nfunction bindAsObject(target, document, resolve, reject, extraOptions) {\n  const options = Object.assign({}, DEFAULT_OPTIONS$1, extraOptions);\n  let unsubscribe = noop;\n  function onValueCallback(snapshot) {\n    const value = options.serialize(snapshot);\n    target.value = value;\n    resolve(value);\n  }\n  if (options.once) {\n    get(document).then(onValueCallback).catch(reject);\n  } else {\n    unsubscribe = onValue(document, onValueCallback, reject);\n  }\n  return (reset) => {\n    unsubscribe();\n    if (reset) {\n      const value = typeof reset === \"function\" ? reset() : null;\n      target.value = value;\n    }\n  };\n}\nfunction bindAsArray(target, collection, resolve, reject, extraOptions) {\n  const options = Object.assign({}, DEFAULT_OPTIONS$1, extraOptions);\n  let arrayRef = options.wait ? [] : target;\n  if (!options.wait) {\n    target.value = [];\n  }\n  let removeChildAddedListener = noop;\n  let removeChildChangedListener = noop;\n  let removeChildRemovedListener = noop;\n  let removeChildMovedListener = noop;\n  let removeValueListener = noop;\n  if (options.once) {\n    get(collection).then((data) => {\n      const array = [];\n      data.forEach((snapshot) => {\n        array.push(options.serialize(snapshot));\n      });\n      resolve(target.value = array);\n    }).catch(reject);\n  } else {\n    removeChildAddedListener = onChildAdded(\n      collection,\n      (snapshot, prevKey) => {\n        const array = unref(arrayRef);\n        const index = prevKey ? indexForKey(array, prevKey) + 1 : 0;\n        array.splice(index, 0, options.serialize(snapshot));\n      },\n      reject\n    );\n    removeChildRemovedListener = onChildRemoved(\n      collection,\n      (snapshot) => {\n        const array = unref(arrayRef);\n        array.splice(indexForKey(array, snapshot.key), 1);\n      },\n      reject\n    );\n    removeChildChangedListener = onChildChanged(\n      collection,\n      (snapshot) => {\n        const array = unref(arrayRef);\n        array.splice(\n          indexForKey(array, snapshot.key),\n          1,\n          // cannot be null because it exists\n          options.serialize(snapshot)\n        );\n      },\n      reject\n    );\n    removeChildMovedListener = onChildMoved(\n      collection,\n      (snapshot, prevKey) => {\n        const array = unref(arrayRef);\n        const index = indexForKey(array, snapshot.key);\n        const oldRecord = array.splice(index, 1)[0];\n        const newIndex = prevKey ? indexForKey(array, prevKey) + 1 : 0;\n        array.splice(newIndex, 0, oldRecord);\n      },\n      reject\n    );\n    removeValueListener = onValue(\n      collection,\n      () => {\n        const array = unref(arrayRef);\n        if (options.wait) {\n          target.value = array;\n          arrayRef = target;\n        }\n        resolve(array);\n        removeValueListener();\n      },\n      reject\n    );\n  }\n  return (reset) => {\n    removeValueListener();\n    removeChildAddedListener();\n    removeChildRemovedListener();\n    removeChildChangedListener();\n    removeChildMovedListener();\n    if (reset) {\n      const value = typeof reset === \"function\" ? reset() : [];\n      target.value = value;\n    }\n  };\n}\n\nfunction _useDatabaseRef(reference, localOptions = {}, isList = false) {\n  let unbind = noop;\n  const options = Object.assign({}, DEFAULT_OPTIONS$1, localOptions);\n  const initialSourceValue = unref(reference);\n  const data = options.target || ref();\n  if (process.env.NODE_ENV !== \"production\") {\n    if (options.target && checkWrittenTarget(data, \"useDatabaseObject()/useDatabaseList()\")) {\n      return data;\n    }\n  }\n  if (isSSR()) {\n    options.once = true;\n  }\n  const initialValue = getInitialValue(\n    initialSourceValue,\n    options.ssrKey,\n    data.value,\n    useFirebaseApp()\n  );\n  data.value = initialValue;\n  const hasInitialValue = isList ? (initialValue || []).length > 0 : initialValue !== void 0;\n  let shouldStartAsPending = !hasInitialValue;\n  const error = ref();\n  const pending = ref(false);\n  const promise = shallowRef();\n  const hasCurrentScope = getCurrentScope();\n  let removePendingPromise = noop;\n  function bindDatabaseRef() {\n    const referenceValue = unref(reference);\n    const newPromise = new Promise((resolve, reject) => {\n      unbind(options.reset);\n      if (!referenceValue) {\n        unbind = noop;\n        return resolve(null);\n      }\n      pending.value = shouldStartAsPending;\n      shouldStartAsPending = true;\n      if (Array.isArray(data.value)) {\n        unbind = bindAsArray(\n          data,\n          referenceValue,\n          resolve,\n          reject,\n          options\n        );\n      } else {\n        unbind = bindAsObject(data, referenceValue, resolve, reject, options);\n      }\n    }).catch((reason) => {\n      if (promise.value === newPromise) {\n        error.value = reason;\n      }\n      throw reason;\n    }).finally(() => {\n      if (promise.value === newPromise) {\n        pending.value = false;\n      }\n    });\n    promise.value = newPromise;\n  }\n  let stopWatcher = noop;\n  if (isRef(reference)) {\n    stopWatcher = watch(reference, bindDatabaseRef);\n  }\n  bindDatabaseRef();\n  if (initialSourceValue) {\n    removePendingPromise = addPendingPromise(promise.value, initialSourceValue);\n  }\n  if (hasCurrentScope) {\n    onScopeDispose(stop);\n    if (getCurrentInstance()) {\n      onServerPrefetch(() => promise.value);\n    }\n  }\n  function stop(reset = options.reset) {\n    stopWatcher();\n    removePendingPromise();\n    unbind(reset);\n  }\n  return Object.defineProperties(data, {\n    // allow destructuring without interfering with the ref itself\n    data: { get: () => data },\n    error: { get: () => error },\n    pending: { get: () => pending },\n    promise: { get: () => promise },\n    stop: { get: () => stop }\n  });\n}\n\nfunction useDatabaseList(reference, options) {\n  const data = ref([]);\n  return _useDatabaseRef(\n    reference,\n    {\n      target: data,\n      ...options\n    },\n    true\n  );\n}\nconst useList = useDatabaseList;\nfunction useDatabaseObject(reference, options) {\n  const data = ref();\n  return _useDatabaseRef(reference, {\n    target: data,\n    ...options\n  });\n}\nconst useObject = useDatabaseObject;\nfunction useDatabase(name) {\n  return getDatabase(useFirebaseApp(name));\n}\n\nconst firestoreDefaultConverter = {\n  toFirestore(data) {\n    return data;\n  },\n  fromFirestore(snapshot, options) {\n    return snapshot.exists() ? Object.defineProperties(snapshot.data(options), {\n      id: { value: snapshot.id }\n      // TODO: check if worth adding or should be through an option\n      // It could also be an example in the docs about converters\n      // $meta: {\n      //   value: snapshot.metadata,\n      // },\n      // $ref: { get: () => snapshot.ref },\n    }) : null;\n  }\n};\nfunction extractRefs(doc, oldDoc, subs, options) {\n  if (!isPOJO(doc))\n    return [doc, {}];\n  const dataAndRefs = [\n    {},\n    {}\n  ];\n  const subsByPath = Object.keys(subs).reduce((resultSubs, subKey) => {\n    const sub = subs[subKey];\n    resultSubs[sub.path] = sub.data();\n    return resultSubs;\n  }, {});\n  function recursiveExtract(doc2, oldDoc2, path, result) {\n    oldDoc2 = oldDoc2 || {};\n    const [data, refs] = result;\n    Object.getOwnPropertyNames(doc2).forEach((propertyName) => {\n      const descriptor = Object.getOwnPropertyDescriptor(doc2, propertyName);\n      if (descriptor && !descriptor.enumerable) {\n        Object.defineProperty(data, propertyName, descriptor);\n      }\n    });\n    for (const key in doc2) {\n      const ref = doc2[key];\n      if (\n        // primitives\n        ref == null || // TODO: check and remove\n        // Firestore < 4.13\n        ref instanceof Date || ref instanceof Timestamp || ref instanceof GeoPoint\n      ) {\n        data[key] = ref;\n      } else if (isDocumentRef(ref)) {\n        const refSubKey = path + key;\n        data[key] = // if the ref was already bound, keep the same object\n        // otherwise set the path as a string so it can be bound later\n        // https://github.com/vuejs/vuefire/issues/831\n        // https://github.com/vuejs/vuefire/pull/1223\n        refSubKey in subs ? oldDoc2[key] : ref.path;\n        refs[refSubKey] = ref.converter ? ref : ref.withConverter(\n          options.converter\n        );\n      } else if (Array.isArray(ref)) {\n        data[key] = Array(ref.length);\n        for (let i = 0; i < ref.length; i++) {\n          const newRef = ref[i];\n          if (newRef && newRef.path in subsByPath)\n            data[key][i] = subsByPath[newRef.path];\n        }\n        recursiveExtract(ref, oldDoc2[key] || data[key], path + key + \".\", [\n          data[key],\n          refs\n        ]);\n      } else if (isObject(ref)) {\n        data[key] = {};\n        recursiveExtract(ref, oldDoc2[key], path + key + \".\", [data[key], refs]);\n      } else {\n        data[key] = ref;\n      }\n    }\n  }\n  recursiveExtract(doc, oldDoc, \"\", dataAndRefs);\n  return dataAndRefs;\n}\n\nconst DEFAULT_OPTIONS = {\n  reset: false,\n  wait: true,\n  maxRefDepth: 2,\n  converter: firestoreDefaultConverter,\n  snapshotOptions: { serverTimestamps: \"estimate\" }\n};\nfunction unsubscribeAll(subs) {\n  for (const sub in subs) {\n    subs[sub].unsub();\n  }\n}\nfunction updateDataFromDocumentSnapshot(options, target, path, snapshot, subs, ops, depth, resolve, reject) {\n  const [data, refs] = extractRefs(\n    // Pass snapshot options\n    // @ts-expect-error: FIXME: use better types\n    snapshot.data(options.snapshotOptions),\n    walkGet(target, path),\n    subs,\n    options\n  );\n  ops.set(target, path, data);\n  subscribeToRefs(\n    options,\n    target,\n    path,\n    subs,\n    refs,\n    ops,\n    depth,\n    resolve,\n    reject\n  );\n}\nfunction subscribeToDocument({\n  ref: ref2,\n  target,\n  path,\n  depth,\n  resolve,\n  reject,\n  ops\n}, options) {\n  const subs = /* @__PURE__ */ Object.create(null);\n  let unbind = noop;\n  if (options.once) {\n    getDoc(ref2).then((snapshot) => {\n      if (snapshot.exists()) {\n        updateDataFromDocumentSnapshot(\n          options,\n          target,\n          path,\n          snapshot,\n          subs,\n          ops,\n          depth,\n          resolve,\n          reject\n        );\n      } else {\n        ops.set(target, path, null);\n        resolve();\n      }\n    }).catch(reject);\n  } else {\n    unbind = onSnapshot(\n      ref2,\n      (snapshot) => {\n        if (snapshot.exists()) {\n          updateDataFromDocumentSnapshot(\n            options,\n            target,\n            path,\n            snapshot,\n            subs,\n            ops,\n            depth,\n            resolve,\n            reject\n          );\n        } else {\n          ops.set(target, path, null);\n          resolve();\n        }\n      },\n      reject\n    );\n  }\n  return () => {\n    unbind();\n    unsubscribeAll(subs);\n  };\n}\nfunction subscribeToRefs(options, target, path, subs, refs, ops, depth, resolve, reject) {\n  const refKeys = Object.keys(refs);\n  const missingKeys = Object.keys(subs).filter(\n    (refKey) => refKeys.indexOf(refKey) < 0\n  );\n  missingKeys.forEach((refKey) => {\n    subs[refKey].unsub();\n    delete subs[refKey];\n  });\n  if (!refKeys.length || ++depth > options.maxRefDepth)\n    return resolve(path);\n  let resolvedCount = 0;\n  const totalToResolve = refKeys.length;\n  const validResolves = /* @__PURE__ */ Object.create(null);\n  function deepResolve(key) {\n    if (key in validResolves) {\n      if (++resolvedCount >= totalToResolve)\n        resolve(path);\n    }\n  }\n  refKeys.forEach((refKey) => {\n    const sub = subs[refKey];\n    const ref2 = refs[refKey];\n    const docPath = `${path}.${refKey}`;\n    validResolves[docPath] = true;\n    if (sub) {\n      if (sub.path !== ref2.path)\n        sub.unsub();\n      else\n        return;\n    }\n    subs[refKey] = {\n      data: () => walkGet(target, docPath),\n      unsub: subscribeToDocument(\n        {\n          ref: ref2,\n          target,\n          path: docPath,\n          depth,\n          ops,\n          resolve: deepResolve.bind(null, docPath),\n          reject\n        },\n        options\n      ),\n      path: ref2.path\n    };\n  });\n}\nfunction bindCollection(target, collection, ops, resolve, reject, extraOptions) {\n  const options = Object.assign({}, DEFAULT_OPTIONS, extraOptions);\n  const { snapshotListenOptions, snapshotOptions, wait, once } = options;\n  const key = \"value\";\n  let arrayRef = ref(wait ? [] : target.value);\n  if (!wait)\n    ops.set(target, key, []);\n  const originalResolve = resolve;\n  let isResolved;\n  let stopOnSnapshot = noop;\n  const arraySubs = [];\n  const change = {\n    added: ({ newIndex, doc }) => {\n      arraySubs.splice(newIndex, 0, /* @__PURE__ */ Object.create(null));\n      const subs = arraySubs[newIndex];\n      const [data, refs] = extractRefs(\n        // @ts-expect-error: FIXME: wrong cast, needs better types\n        doc.data(snapshotOptions),\n        void 0,\n        subs,\n        options\n      );\n      ops.add(unref(arrayRef), newIndex, data);\n      subscribeToRefs(\n        options,\n        arrayRef,\n        `${key}.${newIndex}`,\n        subs,\n        refs,\n        ops,\n        0,\n        resolve.bind(null, doc),\n        reject\n      );\n    },\n    modified: ({ oldIndex, newIndex, doc }) => {\n      const array = unref(arrayRef);\n      const subs = arraySubs[oldIndex];\n      const oldData = array[oldIndex];\n      const [data, refs] = extractRefs(\n        // @ts-expect-error: FIXME: Better types\n        doc.data(snapshotOptions),\n        oldData,\n        subs,\n        options\n      );\n      arraySubs.splice(newIndex, 0, subs);\n      ops.remove(array, oldIndex);\n      ops.add(array, newIndex, data);\n      subscribeToRefs(\n        options,\n        arrayRef,\n        `${key}.${newIndex}`,\n        subs,\n        refs,\n        ops,\n        0,\n        resolve,\n        reject\n      );\n    },\n    removed: ({ oldIndex }) => {\n      const array = unref(arrayRef);\n      ops.remove(array, oldIndex);\n      unsubscribeAll(arraySubs.splice(oldIndex, 1)[0]);\n    }\n  };\n  function onSnapshotCallback(snapshot) {\n    const docChanges = snapshot.docChanges(snapshotListenOptions);\n    if (!isResolved && docChanges.length) {\n      isResolved = true;\n      let count = 0;\n      const expectedItems = docChanges.length;\n      const validDocs = /* @__PURE__ */ Object.create(null);\n      for (let i = 0; i < expectedItems; i++) {\n        validDocs[docChanges[i].doc.id] = true;\n      }\n      resolve = (data) => {\n        if (data && data.id in validDocs) {\n          if (++count >= expectedItems) {\n            if (wait) {\n              ops.set(target, key, unref(arrayRef));\n              arrayRef = target;\n            }\n            originalResolve(unref(arrayRef));\n            resolve = noop;\n          }\n        }\n      };\n    }\n    docChanges.forEach((c) => {\n      change[c.type](c);\n    });\n    if (!docChanges.length) {\n      if (wait) {\n        ops.set(target, key, unref(arrayRef));\n        arrayRef = target;\n      }\n      resolve(unref(arrayRef));\n    }\n  }\n  if (once) {\n    getDocs(collection).then(onSnapshotCallback).catch(reject);\n  } else {\n    stopOnSnapshot = onSnapshot(collection, onSnapshotCallback, reject);\n  }\n  return (reset) => {\n    stopOnSnapshot();\n    if (reset) {\n      const value = typeof reset === \"function\" ? reset() : [];\n      ops.set(target, key, value);\n    }\n    arraySubs.forEach(unsubscribeAll);\n  };\n}\nfunction bindDocument(target, document, ops, resolve, reject, extraOptions) {\n  const options = Object.assign({}, DEFAULT_OPTIONS, extraOptions);\n  const key = \"value\";\n  const subs = /* @__PURE__ */ Object.create(null);\n  resolve = callOnceWithArg(resolve, () => walkGet(target, key));\n  let stopOnSnapshot = noop;\n  function onSnapshotCallback(snapshot) {\n    if (snapshot.exists()) {\n      updateDataFromDocumentSnapshot(\n        options,\n        target,\n        key,\n        snapshot,\n        subs,\n        ops,\n        0,\n        resolve,\n        reject\n      );\n    } else {\n      ops.set(target, key, null);\n      resolve(null);\n    }\n  }\n  if (options.once) {\n    getDoc(document).then(onSnapshotCallback).catch(reject);\n  } else {\n    stopOnSnapshot = onSnapshot(document, onSnapshotCallback, reject);\n  }\n  return (reset) => {\n    stopOnSnapshot();\n    if (reset) {\n      const value = typeof reset === \"function\" ? reset() : null;\n      ops.set(target, key, value);\n    }\n    unsubscribeAll(subs);\n  };\n}\n\nfunction _useFirestoreRef(docOrCollectionRef, localOptions) {\n  let unbind = noop;\n  const options = Object.assign({}, DEFAULT_OPTIONS, localOptions);\n  const initialSourceValue = unref(docOrCollectionRef);\n  const data = options.target || ref();\n  if (process.env.NODE_ENV !== \"production\") {\n    if (options.target && checkWrittenTarget(data, \"useDocument()/useCollection()\")) {\n      return data;\n    }\n  }\n  if (isSSR()) {\n    options.once = true;\n  }\n  const initialValue = getInitialValue(\n    initialSourceValue,\n    options.ssrKey,\n    data.value,\n    useFirebaseApp()\n  );\n  data.value = initialValue;\n  const hasInitialValue = isCollectionRef(initialSourceValue) ? (initialValue || []).length > 0 : initialValue !== void 0;\n  let shouldStartAsPending = !hasInitialValue;\n  const pending = ref(false);\n  const error = ref();\n  const promise = shallowRef();\n  const hasCurrentScope = getCurrentScope();\n  let removePendingPromise = noop;\n  function bindFirestoreRef() {\n    let docRefValue = unref(docOrCollectionRef);\n    const newPromise = new Promise((resolve, reject) => {\n      unbind(options.reset);\n      if (!docRefValue) {\n        unbind = noop;\n        return resolve(null);\n      }\n      pending.value = shouldStartAsPending;\n      shouldStartAsPending = true;\n      if (!docRefValue.converter) {\n        docRefValue = docRefValue.withConverter(\n          // @ts-expect-error: seems like a ts error\n          options.converter\n        );\n      }\n      unbind = (isDocumentRef(docRefValue) ? bindDocument : bindCollection)(\n        // @ts-expect-error: cannot type with the ternary\n        data,\n        docRefValue,\n        ops,\n        resolve,\n        reject,\n        options\n      );\n    }).catch((reason) => {\n      if (promise.value === newPromise) {\n        error.value = reason;\n      }\n      return Promise.reject(reason);\n    }).finally(() => {\n      if (promise.value === newPromise) {\n        pending.value = false;\n      }\n    });\n    promise.value = newPromise;\n  }\n  let stopWatcher = noop;\n  if (isRef(docOrCollectionRef)) {\n    stopWatcher = watch(docOrCollectionRef, bindFirestoreRef);\n  }\n  bindFirestoreRef();\n  if (initialSourceValue) {\n    removePendingPromise = addPendingPromise(\n      promise.value,\n      initialSourceValue,\n      options.ssrKey\n    );\n  }\n  if (getCurrentInstance()) {\n    onServerPrefetch(() => promise.value);\n  }\n  if (hasCurrentScope) {\n    onScopeDispose(stop);\n  }\n  function stop(reset = options.reset) {\n    stopWatcher();\n    removePendingPromise();\n    unbind(reset);\n  }\n  return Object.defineProperties(data, {\n    error: { get: () => error },\n    data: { get: () => data },\n    pending: { get: () => pending },\n    promise: { get: () => promise },\n    stop: { get: () => stop }\n  });\n}\nconst ops = {\n  set: (target, key, value) => walkSet(target, key, value),\n  add: (array, index, data) => array.splice(index, 0, data),\n  remove: (array, index) => array.splice(index, 1)\n};\n\nfunction useCollection(collectionRef, options) {\n  return _useFirestoreRef(collectionRef, {\n    target: ref([]),\n    ...options\n  });\n}\nfunction useDocument(documentRef, options) {\n  return _useFirestoreRef(documentRef, options);\n}\nfunction useFirestore(name) {\n  return getFirestore(useFirebaseApp(name));\n}\n\nconst databaseUnbinds = /* @__PURE__ */ new WeakMap();\nfunction internalUnbind$1(key, unbinds, reset) {\n  if (unbinds && unbinds[key]) {\n    unbinds[key](reset);\n    delete unbinds[key];\n  }\n}\n\nconst databasePluginDefaults = {\n  bindName: \"$databaseBind\",\n  unbindName: \"$databaseUnbind\"\n};\nfunction databasePlugin(app, pluginOptions, firebaseApp) {\n  const globalOptions = Object.assign({}, databasePluginDefaults, pluginOptions);\n  const { bindName, unbindName } = globalOptions;\n  const GlobalTarget = isVue3 ? app.config.globalProperties : app.prototype;\n  GlobalTarget[unbindName] = function databaseUnbind(key, reset) {\n    internalUnbind$1(key, databaseUnbinds.get(this), reset);\n    delete this.$firebaseRefs[key];\n  };\n  GlobalTarget[bindName] = function databaseBind(key, source, userOptions) {\n    const options = Object.assign({}, globalOptions, userOptions);\n    const target = toRef(this.$data, key);\n    if (!databaseUnbinds.has(this)) {\n      databaseUnbinds.set(this, {});\n    }\n    const unbinds = databaseUnbinds.get(this);\n    if (unbinds[key]) {\n      unbinds[key](options.reset);\n    }\n    if (pluginOptions) {\n      if (!pluginOptions.bindName) {\n        GlobalTarget[\"$rtdbBind\"] = GlobalTarget[bindName];\n      }\n      if (!pluginOptions.unbindName) {\n        GlobalTarget[\"$rtdbUnbind\"] = GlobalTarget[unbindName];\n      }\n    }\n    const scope = getGlobalScope(firebaseApp || useFirebaseApp(), app).run(\n      () => effectScope()\n    );\n    const { promise, stop: _unbind } = scope.run(\n      () => _useDatabaseRef(source, { target, ...options })\n    );\n    const unbind = (reset) => {\n      _unbind(reset);\n      scope.stop();\n    };\n    unbinds[key] = unbind;\n    this.$firebaseRefs[key] = source.ref;\n    return promise.value;\n  };\n  app.mixin({\n    beforeCreate() {\n      this.$firebaseRefs = /* @__PURE__ */ Object.create(null);\n    },\n    created() {\n      let bindings = this.$options.firebase;\n      if (typeof bindings === \"function\") {\n        bindings = bindings.call(this);\n      }\n      if (!bindings)\n        return;\n      for (const key in bindings) {\n        this[bindName](\n          // ts\n          key,\n          bindings[key],\n          globalOptions\n        );\n      }\n    },\n    beforeUnmount() {\n      const unbinds = databaseUnbinds.get(this);\n      if (unbinds) {\n        for (const key in unbinds) {\n          unbinds[key]();\n        }\n      }\n      this.$firebaseRefs = null;\n    }\n  });\n}\nfunction VueFireDatabaseOptionsAPI(pluginOptions) {\n  return (firebaseApp, app) => {\n    return databasePlugin(app, pluginOptions, firebaseApp);\n  };\n}\n\nconst firestoreUnbinds = /* @__PURE__ */ new WeakMap();\nfunction internalUnbind(key, unbinds, reset) {\n  if (unbinds && unbinds[key]) {\n    unbinds[key](reset);\n    delete unbinds[key];\n  }\n}\n\nconst firestorePluginDefaults = {\n  bindName: \"$firestoreBind\",\n  unbindName: \"$firestoreUnbind\"\n};\nconst firestorePlugin = function firestorePlugin2(app, pluginOptions, firebaseApp) {\n  const globalOptions = Object.assign(\n    {},\n    firestorePluginDefaults,\n    pluginOptions\n  );\n  const { bindName, unbindName } = globalOptions;\n  const GlobalTarget = isVue3 ? app.config.globalProperties : app.prototype;\n  GlobalTarget[unbindName] = function firestoreUnbind(key, reset) {\n    internalUnbind(key, firestoreUnbinds.get(this), reset);\n    delete this.$firestoreRefs[key];\n  };\n  GlobalTarget[bindName] = function firestoreBind(key, docOrCollectionRef, userOptions) {\n    const options = Object.assign({}, globalOptions, userOptions);\n    const target = toRef(this.$data, key);\n    if (!firestoreUnbinds.has(this)) {\n      firestoreUnbinds.set(this, {});\n    }\n    const unbinds = firestoreUnbinds.get(this);\n    if (unbinds[key]) {\n      unbinds[key](options.reset);\n    }\n    const scope = getGlobalScope(firebaseApp || useFirebaseApp(), app).run(\n      () => effectScope()\n    );\n    const { promise, stop: _unbind } = scope.run(\n      () => _useFirestoreRef(docOrCollectionRef, {\n        target,\n        ...options\n      })\n    );\n    const unbind = (reset) => {\n      _unbind(reset);\n      scope.stop();\n    };\n    unbinds[key] = unbind;\n    this.$firestoreRefs[key] = // ts\n    docOrCollectionRef;\n    return promise.value;\n  };\n  app.mixin({\n    beforeCreate() {\n      this.$firestoreRefs = /* @__PURE__ */ Object.create(null);\n    },\n    created() {\n      const { firestore } = this.$options;\n      const refs = typeof firestore === \"function\" ? firestore.call(this) : firestore;\n      if (!refs)\n        return;\n      for (const key in refs) {\n        this[bindName](\n          key,\n          // @ts-expect-error: FIXME: there is probably a wrong type in global properties\n          refs[key],\n          globalOptions\n        );\n      }\n    },\n    beforeUnmount() {\n      const unbinds = firestoreUnbinds.get(this);\n      if (unbinds) {\n        for (const subKey in unbinds) {\n          unbinds[subKey]();\n        }\n      }\n      this.$firestoreRefs = null;\n    }\n  });\n};\nfunction VueFireFirestoreOptionsAPI(pluginOptions) {\n  return (firebaseApp, app) => {\n    return firestorePlugin(app, pluginOptions, firebaseApp);\n  };\n}\n\nfunction VueFireAuth(initialUser) {\n  return (firebaseApp, app) => {\n    const user = getGlobalScope(firebaseApp, app).run(\n      () => ref(initialUser)\n    );\n    authUserMap.set(firebaseApp, user);\n    setupOnAuthStateChanged(user, firebaseApp);\n  };\n}\nfunction useFirebaseAuth(name) {\n  return isClient ? getAuth(useFirebaseApp(name)) : null;\n}\n\nfunction useFirebaseStorage(name) {\n  return getStorage(useFirebaseApp(name));\n}\nfunction useStorageFileUrl(storageRef) {\n  const initialSourceValue = unref(storageRef);\n  const url = ref();\n  url.value = getInitialValue(\n    initialSourceValue,\n    void 0,\n    url.value,\n    useFirebaseApp()\n  );\n  const promise = shallowRef(Promise.resolve(null));\n  let removePendingPromise = noop;\n  function refresh() {\n    const storageSource = unref(storageRef);\n    if (storageSource) {\n      promise.value = getDownloadURL(storageSource).then((downloadUrl) => url.value = downloadUrl).catch(() => null);\n    } else {\n      promise.value = Promise.resolve(url.value = null);\n    }\n    return promise.value;\n  }\n  refresh();\n  if (isRef(storageRef)) {\n    watch(storageRef, refresh);\n  }\n  if (initialSourceValue) {\n    removePendingPromise = addPendingPromise(promise.value, initialSourceValue);\n  }\n  if (getCurrentScope()) {\n    onScopeDispose(removePendingPromise);\n  }\n  if (getCurrentInstance()) {\n    onServerPrefetch(() => promise.value);\n  }\n  return { url, refresh, promise };\n}\nfunction useStorageFileMetadata(storageRef) {\n  const initialSourceValue = unref(storageRef);\n  const metadata = shallowRef();\n  if (initialSourceValue) {\n    metadata.value = getInitialValue(\n      initialSourceValue,\n      // 'm ' is a prefix to differentiate from urls since both are stored in the same object\n      \"m \" + initialSourceValue.toString(),\n      metadata.value,\n      useFirebaseApp()\n    );\n  }\n  const promise = shallowRef(\n    Promise.resolve(null)\n  );\n  let removePendingPromise = noop;\n  function refresh() {\n    const storageSource = unref(storageRef);\n    if (storageSource) {\n      promise.value = getMetadata(storageSource).then((data) => metadata.value = data).catch(() => null);\n    } else {\n      promise.value = Promise.resolve(metadata.value = null);\n    }\n    return promise.value;\n  }\n  function update(newMetadata) {\n    const storageSource = unref(storageRef);\n    if (storageSource) {\n      promise.value = updateMetadata(storageSource, newMetadata).then(\n        (newData) => {\n          return metadata.value = newData;\n        }\n      );\n    } else if (process.env.NODE_ENV !== \"production\") {\n      console.warn('[VueFire]: \"update()\" called with no storage source.');\n    }\n    return promise.value;\n  }\n  refresh();\n  if (isRef(storageRef)) {\n    watch(storageRef, refresh);\n  }\n  if (initialSourceValue) {\n    removePendingPromise = addPendingPromise(promise.value, initialSourceValue);\n  }\n  if (getCurrentScope()) {\n    onScopeDispose(removePendingPromise);\n  }\n  if (getCurrentInstance()) {\n    onServerPrefetch(() => promise.value);\n  }\n  return { metadata, update, refresh, promise };\n}\nfunction useStorageFile(storageRef) {\n  const { url, refresh: refreshUrl } = useStorageFileUrl(storageRef);\n  const {\n    metadata,\n    update: updateMetadata2,\n    refresh: refreshMetadata\n  } = useStorageFileMetadata(storageRef);\n  const uploadTask = shallowRef();\n  const snapshot = shallowRef();\n  const uploadError = shallowRef();\n  const uploadProgress = computed(() => {\n    const snap = unref(snapshot);\n    return snap ? snap.bytesTransferred / snap.totalBytes : null;\n  });\n  let unsub = noop;\n  function upload(newData, newMetadata) {\n    const storageSource = unref(storageRef);\n    const currentTask = unref(uploadTask);\n    if (currentTask) {\n      currentTask.cancel();\n    }\n    uploadError.value = null;\n    snapshot.value = null;\n    uploadTask.value = null;\n    url.value = null;\n    metadata.value = null;\n    unsub();\n    if (storageSource) {\n      const newTask = uploadBytesResumable(storageSource, newData, newMetadata);\n      uploadTask.value = newTask;\n      snapshot.value = newTask.snapshot;\n      unsub = newTask.on(\"state_changed\", (newSnapshot) => {\n        snapshot.value = newSnapshot;\n      });\n      return newTask.then((finalSnapshot) => {\n        metadata.value = finalSnapshot.metadata;\n        refreshUrl();\n      }).catch((err) => {\n        uploadError.value = err;\n        return Promise.reject(err);\n      }).finally(() => {\n        unsub();\n        uploadTask.value = null;\n      });\n    }\n  }\n  function refresh() {\n    return Promise.all([refreshUrl(), refreshMetadata()]);\n  }\n  if (isRef(storageRef)) {\n    watch(storageRef, (storageSource) => {\n      if (!storageSource) {\n        if (uploadTask.value) {\n          unsub();\n          uploadTask.value.cancel();\n        }\n        uploadTask.value = null;\n        snapshot.value = null;\n      }\n      refresh();\n    });\n  }\n  if (getCurrentScope()) {\n    onScopeDispose(unsub);\n  }\n  return {\n    url,\n    metadata,\n    snapshot,\n    uploadTask,\n    uploadError,\n    uploadProgress,\n    upload,\n    updateMetadata: updateMetadata2,\n    refresh\n    // promise,\n  };\n}\nconst useStorage = useFirebaseStorage;\nconst useStorageUrl = useStorageFileUrl;\nconst useStorageMetadata = useStorageFileMetadata;\nconst useStorageObject = useStorageFile;\n\nfunction VueFire(app, { firebaseApp, modules = [] }) {\n  app.provide(_FirebaseAppInjectionKey, firebaseApp);\n  for (const firebaseModule of modules) {\n    app.use(firebaseModule.bind(null, firebaseApp));\n  }\n}\n\nexport { VueFire, VueFireAuth, VueFireDatabaseOptionsAPI, VueFireFirestoreOptionsAPI, databasePlugin, firestoreDefaultConverter, firestorePlugin, DEFAULT_OPTIONS$1 as globalDatabaseOptions, DEFAULT_OPTIONS as globalFirestoreOptions, databasePlugin as rtdbPlugin, useCollection, useDatabase, useDatabaseList, useDatabaseObject, useDocument, useFirebaseApp, useFirebaseAuth, useFirebaseStorage, useFirestore, useList, useObject, usePendingPromises, useSSRInitialState, useStorage, useStorageFile, useStorageFileMetadata, useStorageFileUrl, useStorageMetadata, useStorageObject, useStorageUrl };\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}